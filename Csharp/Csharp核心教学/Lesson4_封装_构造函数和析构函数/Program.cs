namespace Lesson4_封装_构造函数和析构函数
{

    #region 知识点一 构造函数
    //基本概念
    //在实例化对象时 会调用的用于初始化的函数
    //如果不写 默认存在一个无参构造函数

    //构造函数的写法
    //1.没有返回值
    //2.函数名和类名必须相同
    //3.没有特殊需求时 一般都是public
    class Person
    {
        public string name;
        public int age;

        //类中允许自己申明无参构造函数
        //结构体不允许
        public Person() 
        {
            name = "ROU";
            age = 18;
        }
        //4.构造函数可以被重载
        //5.this代表当前调用该函数的对象自己
        public Person(int age)
        {
            this.age = age;
        }
        public Person(string name)
        {
            this.name = name;
        }
        public Person(string name, int age):this(name) 
        {
            this.name = name;
            this.age = age;
        }

        //当引用类型的堆内存被回收时，会调用该函数
        //析构函数是当垃圾真正被回收的时候才会调用的函数
        ~Person()
        {

        }
    }

    //注意：
    // 如果不自己实现无参构造函数而实现了有参构造函数 则会失去默认的无参构造
    #endregion


    #region 知识点二 构造函数特殊写法
    //可以通过this重用构造函数代码
    //访问修饰符 构造函数名（函数列表）：this（参数1,参数2.....）
    #endregion


    #region 知识点三 析构函数
    //基本概念
    //当引用类型的堆内存被回收时，会调用该函数
    //对于需要手动管理内存的语言（比如c++），需要在析构函数中做一些内存回收处理
    //但是c#中存在自动垃圾回收机制GC
    //所以我们几乎不会怎么使用析构函数，除非你想在某一个对象被垃圾回收时，做一些特殊处理
    //注意：
    //在unity开发中析构函数几乎不会被使用，所以该知识点只做了解即可

    //基本语法
    //~类名()
    // {
    // }
    #endregion


    #region 知识点四 垃圾回收机制
    //垃圾回收，英语简写GC（Garbage Collector）
    //垃圾回收的过程是在遍历堆（Heap）上动态分配的所有对象
    //通过识别它们是否被引用来确定哪些对象是垃圾，哪些对象仍要被使用
    //所谓的垃圾就是没有被任何变量、对象引用的内容

    //垃圾回收有很多种算法，比如
    //引用计数（Reference Counting）
    //标记清除（Mark Sweep）
    //标记整理（Mark Compact）
    //复制集合（Copy Collection）

    //注意：
    //GC只负责堆（Heap）内存的垃圾回收
    //引用类型都是存在堆（Heap）中的，所以它的分配和释放都通过垃圾回收机制来管理

    //栈（Stack）上的内存是由系统自动管理的
    //值类型在栈（Stack）中分配内存，它们有自己的生命周期，不用对他们进行管理，会自动分配和释放

    //c#中内存回收机制的大概原理
    //0代内存      1代内存        2代内存
    //代的概念：
    //代是垃圾回收机制使用的一种算法（分代算法）
    //新分配的对象都会被配置在第0代内存中
    //每次分配都可能会进行垃圾回收以释放内存（0代内存满时）

    //在一次内存回收过程开始时，垃圾回收器会认为堆中全是垃圾，会进行以下两步
    // 1.标记对象 从根（静态字段、方法参数）开始检查引用对象，标记后为可达对象，未标记为不可达对象
    //   不可达对象就认为是垃圾
    // 2.搬迁对象压缩堆（挂起执行托管代码线程）释放未标记的对象、搬迁可达对象、修改引用地址

    //大对象总被认为是第二代内存 目的是减少性能损耗，提高性能
    //不会对大对象进行搬迁压缩 85000字节（83kb）以上的对象为打对象
    #endregion





    internal class Program
    {
        static void Main(string[] args)
        {

            Person person = new Person("ROU", 21);
            Console.WriteLine(person.age);

            person = null;

            //手动触发垃圾回收的方法
            //一般情况下不会频繁调用
            //都是在loading过场景时才调用
            GC.Collect();

        }
    }

    //总结
    //构造函数
    //实例化对象时调用的函数
    //主要是用来初始化成员变量

    //基本语法
    //不写返回值
    //函数名和类名相同
    //访问修饰符根据需求而定
    //一般为public

    //注意
    //可以重载构造函数
    //可以用this语法重用代码
    //可以在函数中用this区分同名参数和成员变量
    //有参构造会顶掉默认的无参构造

    //析构函数
    //当对象被垃圾回收时调用，主要是用来回收资源或者特殊处理内存
    //基本语法
    //不写返回值
    //不写修饰符
    //不能有参数
    //函数名和类名相同
    //类名前面加~
}
